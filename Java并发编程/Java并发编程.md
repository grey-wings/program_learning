# Java并发编程

## 一、并发编程的底层实现原理  
### 1.volatile  
#### 1.1 定义和实现原理  
见P21  
如果一个字段被声明成volatile，则所有线程看到这个变量的值是一致的。  
对volatile变量写入时，这个变量所在的缓存行的数据写回到系统内存，同时会导致其他处理器的缓存无效。  
#### 1.2 volatile的内存语义  
**可见性**：对一个volatile变量的读，总是能看到**任意线程**对这个变量的最后写入。  
**原子性**：对任意单个volatile变量的写具有原子性，但不保证++操作有原子性。  
volatile读的内存语义是
写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存。  
volatile写和锁的释放有相同的内存语义；volatile读和锁的获取有相同的内存语义。  
**volatile内存语义的实现**：
插入[内存屏障](./%E6%9C%AF%E8%AF%AD%E8%A7%A3%E9%87%8A.md#1.内存屏障)  
在每个volatile写操作的前面插入StoreStore屏障，后面插入StoreLoad屏障；   
在每个volatile读操作的后面插入LoadLoad屏障，后面插入一个LoadStore屏障。    
（似乎是可以刷新所有共享变量？）  
### 2.synchronized   
#### 2.1 定义和实现原理  
见P26  
Java中的每一个对象都可以作为锁。具体表现为以下三种形式：  
对于普通同步方法，锁是当前实例对象。  
对于静态同步方法，锁是当前类的[Class对象](%E6%9C%AF%E8%AF%AD%E8%A7%A3%E9%87%8A.md#2class对象)。
对于同步方法块，锁是synchronize括号里配置的对象。  
#### 2.2 应用  
见P189  
synchronized可以修饰方法或者同步块，它保证在同一个时刻只能有一个线程在同步方法或者同步块中。  
synchronized本质是获取对象的监视器（monitor），这个过程是排他的，没有获取到监视器的线程将被阻塞。  
### 3.原子操作
#### 3.1 处理器实现原子操作  
原子操作有总线锁、缓存锁两种实现。  
总线锁只允许一个处理器在总线上写  
缓存锁启用时，当一个处理器修改缓存行中的数据，缓存锁会阻止其他处理器缓存这个缓存行。  

被操作的数据不能被缓存在处理器内部，或者操作的数据跨多个缓存行时，处理器调用总线锁定。  
#### 3.2 Java实现原子操作  
（1）自旋CAS实现原子操作  
循环进行CAS操作直到成功为止。  
该方法有三个缺点：ABA问题（通过添加版本号解决）、循环时间开销大、只能保证一个变量的原子操作（多个变量可以用锁）。  
（2）用锁实现原子操作。  

## 二、Java内存模型  
### 1.线程通信
Java线程通信示例：  
[![QQ-20220903223307.jpg](https://i.postimg.cc/J7yYYPfh/QQ-20220903223307.jpg)](https://postimg.cc/QV3qHkxL)  
### 2.锁的内存语义  
参考P100  
以ReentrantLock为例，公平锁在释放锁的最后写一个volatile变量state，获取锁时首先读这个volatile变量；非公平锁的释放和公平锁相同，以原子操作（CAS）的方式更新state变量。  
#### 2.1 为什么CAS同时具有volatile读和写的内存语义？  
以Intel x86处理器为例。  
compareAndSwapInt()方法是一个native方法，在上述处理器的汇编代码中，有一条lock前缀。添加该前缀的指令会被禁止和前面与后面的指令重排序，并且把写缓冲区中的**所有**数据刷新到内存中。  
CAS的源码见P104  
### 3.延迟初始化  
见P135  

## 三、Java并发编程基础  
### 1.线程的启动和终止  
见P181
线程启动用start()方法即可。  
线程终止不宜用stop()，因为该方法不保证线程的资源正确释放，可能形成死锁。  
可以使用boolean变量或者中断的方式来终止线程。  
### 2.等待/通知机制  
见P192  
等待/通知的相关方法见下图。  
[![QQ-20220905142057.png](https://i.postimg.cc/4NqD53Mx/QQ-20220905142057.png)](https://postimg.cc/2Vd9jCrs)  
等待/通知机制是指一个线程A调用了对象O的wait()方法进入等待状态，二另一个线程B调用了对象O的notify()或notifyAll()方法，线程A收到通知后从对象O的wait()方法返回。  
·wait中的线程收到通知后不会立刻返回，而是等到发出通知的线程释放锁之后，本线程获取锁才会返回。  
·notify()等待队列中的一个线程移动到同步队列中，而notifyAll()移动所有线程。  
被移动的线程状态由等待变为阻塞。  
### 3.等到超时模式  
调用一个方法等待一段时间，如果该方法能再给定的时间段之内得到结果，那么将结果立刻返回，否则超时返回默认结果。  
该模式范式见P206，示例代码见P207.  
### 4.线程池  
见P211  
### 5.Lock接口  
见P222  
用Lock接口获取锁时，不能写在try里。因为如果在获取锁的时候发生了异常，会引起锁的无故释放。  
在finally块中释放锁，保证获取锁后，锁最终能被释放。  
Lock接口提供的synchronized关键字不具备的主要特性：  
[![QQ-20220905194334.jpg](https://i.postimg.cc/KcNcVbb2/QQ-20220905194334.jpg)](https://postimg.cc/RqWz6jqs)  
Lock的API：  
[![QQ-20220905194439.png](https://i.postimg.cc/8kKccG0b/QQ-20220905194439.png)](https://postimg.cc/hhmcZkgJ)  
Lock接口的实现基本是通过聚合了一个同步器的子类来完成线程访问控制的。  
#### 5.1 同步器  
见P224
队列同步器AbstractQueuedSynchronizer使用了一个int成员变量表示同步状态，通过内置的FIFO队列完成资源获取线程的排队工作。  
[![QQ-20220906141827.jpg](https://i.postimg.cc/VNgXmqqb/QQ-20220906141827.jpg)](https://postimg.cc/Y44vxmyp)  
[![QQ-20220906150914.png](https://i.postimg.cc/8PTt2g7Z/QQ-20220906150914.png)](https://postimg.cc/5jkBzGqz)  
实现自定义同步组件时，将会调用同步器提供的模板方法。  
[![QQ-20220906150914.png](https://i.postimg.cc/8PTt2g7Z/QQ-20220906150914.png)](https://postimg.cc/5jkBzGqz)  
