# Java并发编程

## 一、并发编程的底层实现原理  
### 1.volatile  
#### 1.1 目录
P21 volatile的定义与实现原理  
#### 1.2 定义和实现原理  
如果一个字段被声明成volatile，则所有线程看到这个变量的值是一致的。  
对volatile变量写入时，这个变量所在的缓存行的数据写回到系统内存，同时会导致其他处理器的缓存无效。  
#### 1.3 volatile的内存语义  
**可见性**：对一个volatile变量的读，总是能看到**任意线程**对这个变量的最后写入。  
**原子性**：对任意单个volatile变量的写具有原子性，但不保证++操作有原子性。  
volatile读的内存语义是
写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存。  
volatile写和锁的释放有相同的内存语义；volatile读和锁的获取有相同的内存语义。  
**volatile内存语义的实现**：
插入[内存屏障](./%E6%9C%AF%E8%AF%AD%E8%A7%A3%E9%87%8A.md#1.内存屏障)  
在每个volatile写操作的前面插入StoreStore屏障，后面插入StoreLoad屏障；  
在每个volatile读操作的后面插入LoadLoad屏障，后面插入一个LoadStore屏障。  
### 2.synchronized  
#### （0）目录  
P26 synchronized的定义与实现原理  
#### （1）定义和实现原理  
Java中的每一个对象都可以作为锁。具体表现为以下三种形式：  
对于普通同步方法，锁是当前实例对象。  
对于静态同步方法，锁是当前类的[Class对象](%E6%9C%AF%E8%AF%AD%E8%A7%A3%E9%87%8A.md#2class对象)。
对于同步方法块，锁是synchronize括号里配置的对象。  

### 3.原子操作
#### 3.1 处理器实现原子操作
原子操作有总线锁、缓存锁两种实现。  
总线锁只允许一个处理器在总线上写  
缓存锁启用时，当一个处理器修改缓存行中的数据，缓存锁会阻止其他处理器缓存这个缓存行。  

被操作的数据不能被缓存在处理器内部，或者操作的数据跨多个缓存行时，处理器调用总线锁定。  
#### 3.2 Java实现原子操作  
（1）自旋CAS实现原子操作  
循环进行CAS操作直到成功为止。  
该方法有三个缺点：ABA问题（通过添加版本号解决）、循环时间开销大、只能保证一个变量的原子操作（多个变量可以用锁）。  
（2）用锁实现原子操作。  

### 二、Java内存模型  
#### 1.线程通信
Java线程通信示例：  
[![QQ-20220903223307.jpg](https://i.postimg.cc/J7yYYPfh/QQ-20220903223307.jpg)](https://postimg.cc/QV3qHkxL)  
