# 术语解释

## 1.内存屏障  
一组处理器指令，用于实现对内存操作的顺序限制。  
内存屏障是CPU或编译器在对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作。  
内存屏障类型表：  
[![QQ-20220903223307.jpg](https://i.postimg.cc/rw7rf9gR/QQ-20220903223307.jpg)](https://postimg.cc/v4LTBfJG)  
StoreLoad屏障同时具有前面三个屏障的效果，开销很大。因为当前处理器通常要把所有写缓冲区的数据刷新到内存中。   
## 2.Class对象  
Java反射机制中表示运行时类型信息的类字节码文件保存的就是Class对象，同一类的所有实例只有一个Class对象。 
## 3.锁的分类  
### 3.1 偏向锁  
竞争出现才会释放或升级锁。加锁/解锁不需要额外的消耗。  
**适用场景**：只有一个线程访问同步块场景。  
### 3.2 轻量级锁  
竞争的线程不会被阻塞（采用自旋），提高了程序的响应速度。  
线程阻塞会导致线程从用户态转至内核态，代价比较大。但自旋会消耗CPU。 
**适用场景**：少量线程交替获取锁，同步块执行速度非常快的场景。追求响应时间。  
### 3.3 重量级锁  
线程竞争锁失败后会阻塞。  
### 3.4 乐观锁  
总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，只在更新的时候会判断一下拿到数据到更新数据这段时间别人有没有去更新这个数据。  
### 3.5 悲观锁  
总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞，直到它拿到锁。  
**适用场景**：大量线程同时竞争锁，追求吞吐量。  
## 4.CAS
compare and swap，比较并交换。   
CAS输入一个旧值和一个新值。如果旧值没有发生变化，就交换成新值，否则不变。  
## 5.happens-before  
如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系。  
happens-before的一些常见规则见P53  
happens-before仅仅要求结果可见，不要求前一个操作必须在后一个操作之前执行。  
