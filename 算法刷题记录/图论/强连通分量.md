# 定义
强连通分量是指图的一个极大子图, 该子图中任意两个点都存在一条路径可以直接或间接互相到达。    
若有向图G任意两点都存在一条路径可以直接或间接到达，则称G为强连通图。  

# 有向图求强连通分量的Tarjan算法  
## 1.dfs生成树  
以该图为例：  
![](https://oi-wiki.org/graph/images/dfs-tree.svg)  
有向图的 DFS 生成树主要有 4 种边（不一定全部出现）：  
1.树边（tree edge）：示意图中以黑色边表示，每次搜索找到一个还没有访问过的结点的时候就形成了一条树边。  
2.反祖边（back edge）：示意图中以红色边表示，也被叫做回边，即指向祖先结点的边。  
3.横叉边（cross edge）：示意图中以蓝色边表示，它主要是在搜索的时候遇到了一个已经访问过的结点，但是这个结点 并不是 当前结点的祖先。  
4.前向边（forward edge）：示意图中以绿色边表示（即 ），它是在搜索的时候遇到子树中的结点的时候形成的。  
如果节点u是某个强连通分量在搜索树中遇到的第一个节点，那么这个强连通分量的其余节点肯定在搜索树中以u为根的子树中，u被称为这个强连通分量的根。  
反证法证明：假设有个结点v在该强连通分量中但是不在以u为根的子树中，那么u到v的路径中肯定有一条离开子树的边。但是这样的边只可能是横叉边或者反祖边，然而这两条边都要求指向的结点已经被访问过了，这就和  是第一个访问的结点矛盾了。得证。  
## 2.tarjan  
tarjan基于dfs，每个强连通分量为搜索树中的一颗子树。搜索时把当前搜索树中未处理的结点加入堆栈。  
该算法中每个节点u维护了以下变量：  
1.dfn[u]：深搜遍历时节点u被搜索的次序  
2.low[u]：记录结点 u 或 u 的子树能够追溯到的dfn最小的值（栈中标号的最小点）  、
若**(u, v)**是指向栈中结点的后向边，**low[u] = dfn(v)**    
若**(u, v)**为树边，**low[u] = min{dfn[u], low[v]}**  
**定理**:若dfn[u] = low[u],以u为根的搜索子树上的所有节点构成一个强连通分量  
dfn[u] = low[u]说明u及u的子树结点没有指向u的祖先的边。  
在搜索过程中，对于结点  和与其相邻的结点 （ 不是  的父节点）考虑 3 种情况：  
v未被访问：继续对v进行深度搜索。在回溯过程中，用low[v]更新low[u]。因为存在从u到v的直接路径，所以v能够回溯到的已经在栈中的结点，u也一定能够回溯到。
v被访问过，已经在栈中：根据 low 值的定义，用dfn[v]更新low[u]。
v被访问过，已不在栈中：说明v已搜索完毕，其所在连通分量已被处理，所以不用对其做操作。
Tarjan算法一遍不一定能搜完所有的点。所以我们要对一趟跑下来还没有被访问到的点继续跑Tarjan，判断依据就是看dfn[i]是否为0。  

例程如下：  
```
int n,m;//点数，边数 
int timer;//dfs时间戳 
int stack[N],top;//栈 
int deg[N];//新建图的度 
int dfn[N],low[N]; 
bool instack[N];//是否在栈中 
int head[N],tot;//链式前向星 
int cnt;//强连通分量个数
int belong[N];//所属将连通分量编号
void tarjan(int x)
{
	dfn[x]=low[x]=++timer;//给时间戳
	//入栈 
	stack[++top]=x;
	instack[x]=1;
	int i;
	/*----------------------更新---------------------*/ 
	for(i=head[x];i;i=edge[i].Next)
	{
		int y=edge[i].to;
		if(!dfn[y])
		{
			tarjan(y);
			low[x]=min(low[x],low[y]);
		}
		else if(instack[y]) low[x]=min(low[x],dfn[y]);
	}
	/*---------------------------------------------*/
	if(dfn[x]==low[x])
	{
		int y;
		//找到一个强连通分量 
		cnt++;  
		do  
		{  
			//退栈
			y=stack[top--];  
			instack[y]=false;  
			belong[y]=cnt;//给点赋值所在的强连通分量编号  
		}while(x!=y);  
	} 
}
```    
这个tarjan算法还可以解决割点、割边、双连通分量的问题。  
## 割点
在**无图**连通如果将其中一个点所有连接该点的边去掉，图就不再联通，那么这个点叫做割点  
用taijan算法求割点的流程如下：  
①任选无向图中的一个点，作为树的根，然后通过dfs遍历全图。  
②设dfn[i]代表节点i的dfs序  
③设low[i]代表节点i在不直接返回父亲节点的情况下，通过“绕路”，能够访问到的节点里，最小的dfn值。  
④对于根节点，若其有两棵及以上的子树，则根节点为割点。  
因为如果去掉根节点，两棵子树将无法互相连通。  
⑤对于非根节点u，若存在一子节点v，无法通过“绕路”，访问到u除其自己外的祖先节点，则u为割点。  
因为一旦去除u，u的祖先节点将与v互不连通。  
此时，low[u] >= dfn[u] 。  
即：除了直接经过它的父亲以外，一个点不能通过其他路径到达不是它父亲的其他祖先。  
## 割边  
和割点差不多，叫做桥。  
对于一个无向图，如果删掉一条边后图中的连通分量数增加了，则称这条边为桥或者割边。严谨来说，就是：假设有连通图 G = {V, E}，e是其中一条边，如果G - e是不连通的，则边e是图G的一条割边（桥）。
比如说，下图中，  
![](https://oi-wiki.org/graph/images/bridge1.svg)  
红色的边就是割边。  
求割边的实现和求割点差不多，只要把条件改成low[v] > dfn[u]即可，这时uv所连的边即是割边。顶点v不能回到祖先，也没有另外一条回到父亲的路。  

