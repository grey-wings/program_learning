# 动态规划刷题记录（2）--背包问题

## 纯01背包问题  
背包问题中最简单的是01背包问题。在LeetCode中没有纯01背包问题，只有对这种问题的改编应用。这里先来分析纯01背包问题。  
在[代码随想录](https://github.com/youngyangyang04/leetcode-master)的pdf中，原始01背包问题描述如下：  
**有N件物品和⼀个最多能被重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能⽤⼀次，求解将哪些物品装⼊背包⾥物品价值总和最大。**  
对于这个问题，最常见的二维dp的数组是这么定义的：  
dp[i][j]表示从下标为[0-i]的物品⾥任意取，放进容量为j的背包，价值总和最⼤是多少。
这是代码随想录写的解释，对于i的作用，笔者认为还可以看成从第0个物品开始遍历每个物品并决定是否将其放入背包。取值为i时即是遍历（判断）到第i个物品。两种解释是一样的，只要读者自行判断哪种更加简单即可。  
递推公式推导：  
对于dp[i][j]，第i个物品可以取也可以不取，如果取了，值就是dp[i - 1][j - weight[i]] + value[i]；如果没取，值就是dp[i - 1][j].  
初始化:j = 0时，全部为0，因为什么包里什么东西都没有放。  
i = 0时，当j < weight[0]时，取值为0，因为这种情况放不下第一个物品，否则取值为value[0].  
其余的就可以通过这些初始化后的值进行递推。
代码就不写了，请参考代码随想录pdf的代码。  

在[动态规划刷题记录（1）](https://github.com/grey-wings/cpp_learning_process/blob/main/%E4%B8%80%E4%BA%9B%E8%87%AA%E5%B7%B1%E5%86%99%E7%9A%84%E5%9E%83%E5%9C%BE%E9%A2%98/%E5%8A%A8%E8%A7%84/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%881%EF%BC%89--%E5%9F%BA%E7%A1%80%E9%A2%98.md)的题目**LeetCode746--使用最小花费爬楼梯**中，介绍了只维护两个dp数组值来节省空间的方法，称为**滚动数组**。  
因为在上面的分析中，第i个物品的状态推导方程只由i - 1时的状态推出，因此可以省略前面的所有i的状态，只保留dp数组j的那一维。将i - 1时的dp数组值拷贝到i时的数组。  
这么写可能很不清除，但是具体的公式可以解决问题：  
**新的dp[j]表示装了重量为j的物品时最大的总价值。  
dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);**  

如果所有价值都是正的，那么所有dp数组都设为0即可。但如果有负数价值，则dp数组需要全部设为负无穷，以免设为0在取max时将负数的价值覆盖掉。  
遍历方式需要选择j从大到小。
这一点其实和上面二维dp在i == 0时的初始化一样。虽然上面写的时候将j > weight[0]的情况全部设为了value[0]。  
从大到小的原因是如果从小到大会导致一些物品被加两遍。下面举例说明（这里引用了代码随想录pdf中的例子）：  
背包总容量为4.  
物品如下：  
|    | 重量 | 价值 |  
|----|------|------|  
|物品0 | 1 | 15 |  
|物品1 | 3 | 20 |  
|物品2 | 4 | 30 |   

先来看一下从大到小遍历：  
第一轮循环i = 0，j从4（最大值）循环到weight[i]（因为当j < weight[i]时，不可能再有物品i的位置，也就是可以确定物品i是不会放入的，那这种情况在其他的循环中会被遍历到），当j == 4时，dp[4] = max(0, dp[4 - 1] + 15) = 15;当j == 3时，dp[3] = max(0, dp[2] + 15) = 15;j == 2时，dp[2] = max(0, dp[1] + 15) = 15, dp[1] = 15, dp[0] = 0;  
然后循环到i = 1，j == 4时，dp[4] = max(15, dp[4 - 3] + 20) = 35;j == 3时，dp[3] = max(15, dp[3 - 3] + 20) = 20;j -- 2时，直接退出不进行计算，因为如果要进行计算的话，dp[2 - 3]下标是负的，也就是说j == 2的时候放不进物品1，那dp[2]的取值也就是原来dp[2]的取值，所以到这一步直接退就好了。  
那么从小到大遍历会怎么样？  
第一轮循环i = 0，j == 1时，dp[1] = max(0, dp[1 - 1] + 15) = 15，j == 2时，dp[2] = max(0, dp[2 - 1] + 15) = 30.那么这里就看得很清楚了，从小到大循环导致了物品0被累加了两遍！这显然是不符合01背包的定义的（但是符合完全背包的定义）。  
代码同样不写，请参考代码随想录。  

## 01背包问题题目：    
### [LeetCode416--分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/)  
这个题相当于求一个和为sum（所有元素之和）/ 2的子集。  
可以看成一个背包，每个数都是物体，重量和价值都为这个数的大小。  
dp[i]表示最大载重为i的背包。因为对于载重为dp[i]的背包而言，即使载满，价值也只有i。因此最大载重sum / 2的背包当且仅当最大价值是sum / 2时，能够分割出题目要求的等和子集。  
也就是说，求dp[sum / 2]，看他的值是否等于sum / 2.  
所有数都是正的，因此dp数组全部初始化为0.从sum开始向下更新。  
代码如下：  
```java 
class Solution {
    public boolean canPartition(int[] nums) {
        int sum = 0;
        for (int i : nums)
            sum += i;
        int[] dp = new int[sum + 1];
        for (int i = 0; i < nums.length; i++)
            for (int j = sum; j >= nums[i]; j--)
                dp[j] = Math.max(dp[j - nums[i]] + nums[i], dp[j]);
        return dp[sum / 2] == sum / 2.0;
    }
}
```  
注意最后sum是除以2.0，因为sum可能是单数，这样会错判。  
## 完全背包问题：  
完全背包问题和01背包问题的区别就在于一维dp时从物品重量小到大循环。这样一个物体就可以被加很多遍（见上面对01背包循环方向要求的分析）。  
另外，一维01背包要求物品循环在外层，重量循环在内层，完全背包则没有循环内外要求。（分析见代码随想录）  

## 完全背包问题题目：  
### [LeetCode322--零钱兑换](https://leetcode-cn.com/problems/coin-change/submissions/)  
由于可以选取任何数量的金币，因此可以看成一个完全背包问题。可以设每个金币的面值是物品的重量，总金额amount是背包的容量，每个物品的价值都是1.不同的是这题要求最小值。  
令dp[j]表示当总金额为j时，需要的最少金币数量。  
dp[j] = min(dp[j = coins[i]] + 1, dp[j])  
意思是如果通过增加一枚当前遍历到的面值的金币来凑金额j，那么金币数将是dp[j = coins[i]] + 1，如果这个数比现有的方案要少，就可以更新dp数组。  
仍然采用从小到大循环，使一个物体可以加很多遍，推导如下（打草稿，看不懂就不看）：  
![image](https://user-images.githubusercontent.com/74122331/151149787-d1373282-bc95-4ca4-82ca-2a1afea9f523.png)  
dp[0]初始化为0，由于单枚金币更新数值的需要（比如，第一枚金币价值为1，则dp[1]为dp[1]原值和dp[0] + 1的最小值，则dp[0]应该取0），其余所有dp数组的值取无穷大。由于更新dp数组时要处理一个为dp[x] + 1的数，因此dp[x]的初值不宜设为LL_MAX  
代码如下：  
```cpp
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        ll dp[amount + 1];
        dp[0] = 0;
        fu (i, 1, amount)
            dp[i] = LLONG_MAX - 2;
        fu (i, 0, coins.size() - 1)
            fu (j, coins[i], amount) {
            dp[j] = min(dp[j], dp[j - coins[i]] + 1);
        }
        return (dp[amount] == LLONG_MAX - 2) ? -1 : dp[amount];
    }
};
```  
### [LeetCode518--零钱兑换II](https://leetcode-cn.com/problems/coin-change-2/)  

### [LeetCode279--完全平方数](https://leetcode-cn.com/problems/perfect-squares/)  
一个完全背包问题，物品就是小于n的平方数  
因为这个问题是要最小化物品的个数，因此物品的个数就是价值，物品的重量就是平方数的数值。  
这里背包必须装满  
定义dp[i]为将数i拆分为平方数的和的最小个数  
暂时先初始化dp[1] = 1, dp[2] = 2  
